<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Kristof Achten | Portfolio &amp; Blog</title><link>https://kristofachten.github.io/posts/</link><description>Recent content in Posts on Kristof Achten | Portfolio &amp; Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 07 Dec 2020 12:06:25 +0100</lastBuildDate><atom:link href="https://kristofachten.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Day 7: Bags</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day7/</link><pubDate>Mon, 07 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day7/</guid><description>Intro Interesting challenge today: recursion! We&amp;rsquo;ve landed at the airport and get to take on the exciting challenge of retrieving our bags from the carousel of doom. Fortunately, bags are color coded. Unfortunately, the bags can be inside each other with respect to a set of predefined regulations. Our puzzle input is this set of regulations, which looks a bit like this:
light red bags contain 1 bright white bag, 2 muted yellow bags.</description></item><item><title>Day 6: Customs</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day6/</link><pubDate>Sun, 06 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day6/</guid><description>Intro We&amp;rsquo;re dealing with customs forms today. Luckily, they&amp;rsquo;re of a rather simple format: each line represents a passenger, and each letter on that line represents a question to which they answered &amp;lsquo;yes&amp;rsquo; to. Passengers are grouped together, separated in the input by an empty line.
abcx abcy abcz In this example, there is one group of 3 passengers, where there are 6 questions to which anyone answered &amp;ldquo;yes&amp;rdquo;: a, b, c, x, y, and z.</description></item><item><title>Day 5: Binary Boarding</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day5/</link><pubDate>Sat, 05 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day5/</guid><description>Intro Apparently, we&amp;rsquo;re boarding a plane today. Surely toboggans can fly, no? Especially when Santa&amp;rsquo;s the one riding it. Anyway, today&amp;rsquo;s input is a list of Welsh words :-). Each line looks as follows:
BFFFBBFRRR B stands for &amp;lsquo;Back&amp;rsquo;, F stands for &amp;lsquo;Front&amp;rsquo;, L stands for &amp;lsquo;Left&amp;rsquo;, and R for &amp;lsquo;Right. There are 128 rows and 8 colums in the plane. Given this initial configuration:
F and B specify which row you&amp;rsquo;re in on the plane F means to take the lower half, keeping rows 0 through 63.</description></item><item><title>Day 4: Passport Processing</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day4/</link><pubDate>Fri, 04 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day4/</guid><description>Intro Aah yes, papers please! Today, we&amp;rsquo;re determining which passports get stamped and which do not! Our input is, to no surprise, a list of passports of which each passport is defined as follows:
iyr:2019 hcl:#602927 eyr:1967 hgt:170cm ecl:brn pid:012533040 byr:1946 They are simple key:value pairs, seperated over multiple lines.
Solution As usual, we start by seperating our raw input into usable chunks. This time, each passport (because it can contain multiple lines) is separated by an empty line.</description></item><item><title>Day 3: Toboggan Trajectory</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day3/</link><pubDate>Thu, 03 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day3/</guid><description>Intro Let&amp;rsquo;s get down to sleighing! Today, we&amp;rsquo;re hopping on a toboggan and see how many trees we can fell.
Our input is 2D-map/layout provided as a data-matrix:
X.##....... #...#...#.. .#....#..#. ..#.#...#.# .#...##..#. ..#.##..... .#.#.#....# .#........# #.##...#... #...##....# .#..#...#.# In this input, # represents a tree and . is just open space. X is our starting position.
The data pattern repeats itself to the right:
.##.........##.........##.........##.........##.........##....... ---&amp;gt; #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .</description></item><item><title>Day 2: Passwords</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day2/</link><pubDate>Wed, 02 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day2/</guid><description>Intro Today, we&amp;rsquo;re dealing with passwords. Given a defined policy, we&amp;rsquo;ll need to determine which passwords are valid with respect to that policy. The policies are defined as follows:
1-3 a: abcde Solution Again, we start by splitting up our input:
val input = rawInput.split(&amp;#39;\n&amp;#39;) Part 1 For part 1, the policy is simple. Given the example above:
1 and 3 are the minimal and maximal occurences that the given character a can have in the string abcde In this case, we&amp;rsquo;re all good, because a appears only once and thus lies between [1, 3] Given the input 2-3 d: abcd - we would conclude that the password is invalid as d only appears once, which is not part of [2, 3] To tackle this problem, I started by creating a generic higher-order function findValidPwds() which takes a decision-function (which decides whether or not a policy is met) as its input.</description></item><item><title>Day 1: Expense report</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day1/</link><pubDate>Tue, 01 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day1/</guid><description>Intro It&amp;rsquo;s that time of the year again: the time where we help Santa and his elves by solving&amp;hellip; well&amp;hellip; programming puzzles? The use of it may be debatable, but it sure is a lot of fun if you&amp;rsquo;re into programming!
This year, I had some trouble deciding which programming language to use for the challenges. My colleagues suggested Kotlin since it inherently just is an awesome language, but as I&amp;rsquo;m currently following an introductory course to Angular, it wouldn&amp;rsquo;t be a stupid decision to go for something like TypeScript or JavaScript either.</description></item></channel></rss>