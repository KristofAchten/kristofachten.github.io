<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Kristof Achten | Portfolio &amp; Blog</title><link>https://divyak.github.io/posts/</link><description>Recent content in Posts on Kristof Achten | Portfolio &amp; Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 02 Dec 2020 12:06:25 +0100</lastBuildDate><atom:link href="https://divyak.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Day 2: Passwords</title><link>https://divyak.github.io/posts/advent-of-code-2020/day2/</link><pubDate>Wed, 02 Dec 2020 12:06:25 +0100</pubDate><guid>https://divyak.github.io/posts/advent-of-code-2020/day2/</guid><description>Intro Today, we&amp;rsquo;re dealing with passwords. Given a defined policy, we&amp;rsquo;ll need to determine which passwords are valid with respect to that policy. The policies are defined as follows:
1-3 a: abcde Solution Again, we start by splitting up our input:
val input = rawInput.split(&amp;#39;\n&amp;#39;) Part 1 For part 1, the policy is simple. Given the example above:
1 and 3 are the minimal and maximal occurences that the given character a can have in the string abcde In this case, we&amp;rsquo;re all good, because a appears only once and thus lies between [1, 3] Given the input 2-3 d: abcd - we would conclude that the password is invalid as d only appears once, which is not part of [2, 3] To tackle this problem, I started by creating a generic higher-order function findValidPwds() which takes a decision-function (which decides whether or not a policy is met) as its input.</description></item><item><title>Day 1: Expense report</title><link>https://divyak.github.io/posts/advent-of-code-2020/day1/</link><pubDate>Tue, 01 Dec 2020 12:06:25 +0100</pubDate><guid>https://divyak.github.io/posts/advent-of-code-2020/day1/</guid><description>Intro It&amp;rsquo;s that time of the year again: the time where we help Santa and his elves by solving&amp;hellip; well&amp;hellip; programming puzzles? The use of it may be debatable, but it sure is a lot of fun if you&amp;rsquo;re into programming!
This year, I had some trouble deciding which programming language to use for the challenges. My colleagues suggested Kotlin since it inherently just is an awesome language, but as I&amp;rsquo;m currently following an introductory course to Angular, it wouldn&amp;rsquo;t be a stupid decision to go for something like TypeScript or JavaScript either.</description></item></channel></rss>