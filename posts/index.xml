<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Kristof Achten | Portfolio &amp; Blog</title><link>https://kristofachten.github.io/posts/</link><description>Recent content in Posts on Kristof Achten | Portfolio &amp; Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 04 Dec 2020 12:06:25 +0100</lastBuildDate><atom:link href="https://kristofachten.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Day 4: Passport Processing</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day4/</link><pubDate>Fri, 04 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day4/</guid><description>Intro Aah yes, papers please! Today, we&amp;rsquo;re determining which passports get stamped and which do not! Our input is, to no surprise, a list of passports of which each passport is defined as follows:
iyr:2019 hcl:#602927 eyr:1967 hgt:170cm ecl:brn pid:012533040 byr:1946 They are simple key:value pairs, seperated over multiple lines.
Solution As usual, we start by seperating our raw input into usable chunks. This time, each passport (because it can contain multiple lines) is separated by an empty line.</description></item><item><title>Day 3: Toboggan Trajectory</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day3/</link><pubDate>Thu, 03 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day3/</guid><description>Intro Let&amp;rsquo;s get down to sleighing! Today, we&amp;rsquo;re hopping on a toboggan and see how many trees we can fell.
Our input is 2D-map/layout provided as a data-matrix:
X.##....... #...#...#.. .#....#..#. ..#.#...#.# .#...##..#. ..#.##..... .#.#.#....# .#........# #.##...#... #...##....# .#..#...#.# In this input, # represents a tree and . is just open space. X is our starting position.
The data pattern repeats itself to the right:
.##.........##.........##.........##.........##.........##....... ---&amp;gt; #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#.. .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#. ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.# .</description></item><item><title>Day 2: Passwords</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day2/</link><pubDate>Wed, 02 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day2/</guid><description>Intro Today, we&amp;rsquo;re dealing with passwords. Given a defined policy, we&amp;rsquo;ll need to determine which passwords are valid with respect to that policy. The policies are defined as follows:
1-3 a: abcde Solution Again, we start by splitting up our input:
val input = rawInput.split(&amp;#39;\n&amp;#39;) Part 1 For part 1, the policy is simple. Given the example above:
1 and 3 are the minimal and maximal occurences that the given character a can have in the string abcde In this case, we&amp;rsquo;re all good, because a appears only once and thus lies between [1, 3] Given the input 2-3 d: abcd - we would conclude that the password is invalid as d only appears once, which is not part of [2, 3] To tackle this problem, I started by creating a generic higher-order function findValidPwds() which takes a decision-function (which decides whether or not a policy is met) as its input.</description></item><item><title>Day 1: Expense report</title><link>https://kristofachten.github.io/posts/advent-of-code-2020/day1/</link><pubDate>Tue, 01 Dec 2020 12:06:25 +0100</pubDate><guid>https://kristofachten.github.io/posts/advent-of-code-2020/day1/</guid><description>Intro It&amp;rsquo;s that time of the year again: the time where we help Santa and his elves by solving&amp;hellip; well&amp;hellip; programming puzzles? The use of it may be debatable, but it sure is a lot of fun if you&amp;rsquo;re into programming!
This year, I had some trouble deciding which programming language to use for the challenges. My colleagues suggested Kotlin since it inherently just is an awesome language, but as I&amp;rsquo;m currently following an introductory course to Angular, it wouldn&amp;rsquo;t be a stupid decision to go for something like TypeScript or JavaScript either.</description></item></channel></rss>